<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    
    <!-- Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-H57NFG20DE"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'G-H57NFG20DE');
    </script>

    <title>Colordle 3D - Explore Color Space</title>
    <meta name="description" content="Visualize the CIELAB color space in 3D.">
    <meta property="og:title" content="Colordle 3D Color Explorer">
    <meta property="og:url" content="https://osmanyo.github.io/colordle/explore.html">

    <style>
        /* PREVENT SCROLLING / BOUNCING ON MOBILE */
        html, body { 
            margin: 0; padding: 0; width: 100%; height: 100%; 
            overflow: hidden; background: #050505; 
            font-family: 'Helvetica Neue', Arial, sans-serif; 
            user-select: none; -webkit-user-select: none; 
            touch-action: none; /* Critical for smooth controls */
        }
        
        /* --- UI OVERLAYS --- */
        #instructions {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: white; text-align: center; pointer-events: none;
            background: rgba(0,0,0,0.85); padding: 30px; border-radius: 12px;
            border: 1px solid #555; width: 400px; max-width: 85%;
            box-shadow: 0 0 50px rgba(0,0,0,0.8); z-index: 10;
        }

        #instructions a { pointer-events: auto; cursor: pointer; }
        
        #crosshair {
            position: absolute; top: 50%; left: 50%; width: 8px; height: 8px;
            background: rgba(255, 255, 255, 0.8); border-radius: 50%;
            transform: translate(-50%, -50%); pointer-events: none;
            mix-blend-mode: difference; z-index: 5;
            transition: width 0.1s, height 0.1s;
        }

        /* HUD */
        #hud {
            position: absolute; top: 20px; left: 50%; transform: translateX(-50%);
            text-align: center;
            min-width: 200px; max-width: 90%;
            pointer-events: none;
            color: #fff; font-family: monospace; 
            background: rgba(0,0,0,0.6); padding: 10px 25px; border-radius: 30px;
            border: 1px solid #444; display: none; 
            backdrop-filter: blur(4px);
        }

        /* SETTINGS PANEL */
        #settingsIcon {
            position: absolute; top: 20px; right: 20px; cursor: pointer; z-index: 20; opacity: 0.7;
        }
        #settingsIcon:hover { opacity: 1; }
        #settingsIcon svg { width: 24px; height: 24px; fill: white; }

        #settingsPanel {
            position: absolute; top: 60px; right: 20px; width: 260px;
            background: rgba(20, 20, 20, 0.95); border: 1px solid #444;
            padding: 15px; border-radius: 8px; color: white;
            display: none; z-index: 20;
        }

        .setting-row { margin-bottom: 12px; }
        .setting-label-row { display: flex; justify-content: space-between; margin-bottom: 4px; }
        .setting-label { font-size: 12px; color: #aaa; }
        .setting-value { font-size: 12px; color: #00d2ff; font-weight: bold; }
        
        input[type=range] { width: 100%; cursor: pointer; }
        select, input[type=text] { 
            width: 100%; background: #111; color: white; 
            border: 1px solid #555; padding: 6px; border-radius: 4px; box-sizing: border-box;
        }
        button#goBtn {
            width: 100%; margin-top: 5px; padding: 6px; cursor: pointer;
            background: #00d2ff; border: none; font-weight: bold; border-radius: 4px;
        }

        .key { border: 1px solid #888; padding: 2px 6px; border-radius: 4px; font-weight: bold; background: #222; }

        #loading {
            position: absolute; top: 20px; left: 50%; transform: translateX(-50%);
            color: #00d2ff; font-family: monospace; font-weight: bold;
        }
        
        .lab-desc { font-size: 12px; color: #aaa; margin-top: 10px; line-height: 1.4; text-align: left;}

        /* MOBILE HINT */
        #mobileHint {
            position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
            color: rgba(255,255,255,0.5); text-align: center; width: 100%;
            font-size: 12px; pointer-events: none; display: none;
            text-shadow: 0 1px 2px rgba(0,0,0,1);
        }
        
        /* Virtual Joystick Zone Visuals (Optional, for debugging areas) */
        .touch-zone { position: absolute; top:0; height: 100%; width: 50%; z-index: 1; }
        #leftZone { left: 0; }
        #rightZone { right: 0; }
    </style>
</head>
<body>

    <div id="loading">Loading Universe...</div>
    <div id="crosshair"></div>
    
    <!-- Touch Zones (Invisible) -->
    <div id="leftZone" class="touch-zone"></div>
    <div id="rightZone" class="touch-zone"></div>

    <!-- SETTINGS ICON -->
    <div id="settingsIcon">
        <svg viewBox="0 0 24 24"><path d="M19.14,12.94c0.04-0.3,0.06-0.61,0.06-0.94c0-0.32-0.02-0.64-0.07-0.94l2.03-1.58c0.18-0.14,0.23-0.41,0.12-0.61 l-1.92-3.32c-0.12-0.22-0.37-0.29-0.59-0.22l-2.39,0.96c-0.5-0.38-1.03-0.7-1.62-0.94L14.4,2.81c-0.04-0.24-0.24-0.41-0.48-0.41 h-3.84c-0.24,0-0.43,0.17-0.47,0.41L9.25,5.35C8.66,5.59,8.12,5.92,7.63,6.29L5.24,5.33c-0.22-0.08-0.47,0-0.59,0.22L2.74,8.87 C2.62,9.08,2.66,9.34,2.86,9.48l2.03,1.58C4.84,11.36,4.8,11.69,4.8,12s0.02,0.64,0.07,0.94l-2.03,1.58 c-0.18,0.14-0.23,0.41-0.12,0.61l1.92,3.32c0.12,0.22,0.37,0.29,0.59,0.22l2.39-0.96c0.5,0.38,1.03,0.7,1.62,0.94l0.36,2.54 c0.05,0.24,0.24,0.41,0.48,0.41h3.84c0.24,0,0.44-0.17,0.47-0.41l0.36-2.54c0.59-0.24,1.13-0.56,1.62-0.94l2.39,0.96 c0.22,0.08,0.47,0,0.59-0.22l1.92-3.32c0.12-0.22,0.07-0.47-0.12-0.61L19.14,12.94z M12,15.6c-1.98,0-3.6-1.62-3.6-3.6 s1.62-3.6,3.6-3.6s3.6,1.62,3.6,3.6S13.98,15.6,12,15.6z"/></svg>
    </div>

    <!-- SETTINGS PANEL -->
    <div id="settingsPanel">
        <div class="setting-row">
            <label class="setting-label">Find Color (Name or Hex)</label>
            <input type="text" id="searchInput" placeholder="e.g. Red or #ff0000">
            <button id="goBtn">Teleport</button>
        </div>
        <hr style="border-color: #333; margin: 15px 0;">
        
        <div class="setting-row">
            <div class="setting-label-row">
                <span class="setting-label">Dot Size</span>
                <span id="sizeVal" class="setting-value">0.8</span>
            </div>
            <input type="range" id="sizeSlider" min="0.05" max="5.0" step="0.05" value="0.8">
        </div>

        <div class="setting-row">
            <label class="setting-label">Shape</label>
            <select id="shapeSelect">
                <option value="square">Square</option>
                <option value="circle">Circle</option>
            </select>
        </div>

        <div class="setting-row">
            <div class="setting-label-row">
                <span class="setting-label">Fly Speed</span>
                <span id="speedVal" class="setting-value">1.0</span>
            </div>
            <input type="range" id="speedSlider" min="0.01" max="8.0" step="0.1" value="1.0">
        </div>
    </div>
    
    <!-- START SCREEN -->
    <div id="instructions">
        <h1>Color Space (LAB)</h1>

        <div style="font-size: 13px; color: #aaa; margin-bottom: 15px; line-height: 1.4;">
            This space includes only the named colors from the full list 
            <a href="https://github.com/meodai/color-names" target="_blank" style="color: #00d2ff; text-decoration: none; border-bottom: 1px dotted #00d2ff;">available here</a>.
        </div>

        <p>Hover over dots to see color names.</p>
        <hr style="border-color: #333; margin: 15px 0;">
        <p>Move: <span class="key">W</span> <span class="key">A</span> <span class="key">S</span> <span class="key">D</span></p>
        <p>Fly Up: <span class="key">Space</span> / Down: <span class="key">Shift</span></p>
        <p>Look: <b>Mouse</b></p>
        
        <div class="lab-desc">
            <b>What is this?</b><br>
            This is the <b>CIELAB</b> color space. Unlike RGB (a cube), LAB organizes colors by how humans perceive them.<br><br>
            <b>↑ Up/Down (L):</b> Lightness<br>
            <b>↔ X Axis (A):</b> Green vs Red<br>
            <b>↔ Z Axis (B):</b> Blue vs Yellow<br><br>
            You can teleport to a given color name from the settings on the top right.
        </div>

        <p id="startMsg" style="margin-top:20px; font-size:0.9em; color:#888;">Click to Start. Press <b>ESC</b> for Settings.</p>

        <a href="index.html" style="display: block; margin-top: 15px; color: #00d2ff; text-decoration: none; font-weight: bold; pointer-events: auto;">
            ← Back to Colordle
        </a>
    </div>

    <!-- HUD -->
    <div id="hud">
        <div id="colorName" style="font-size: 1.4em; font-weight: bold;">---</div>
        <div id="colorHex" style="color: #ccc; font-size: 0.9em; margin-top:2px;">---</div>
    </div>

    <!-- MOBILE HINT -->
    <div id="mobileHint">Left: Drag to Move • Right: Drag to Look</div>

    <script type="module">
        import * as THREE from 'https://esm.sh/three@0.160.0';
        import { PointerLockControls } from 'https://esm.sh/three@0.160.0/examples/jsm/controls/PointerLockControls.js';
        import { converter, parse } from 'https://esm.sh/culori@3';

        // --- SETTINGS STATE ---
        let settings = {
            speed: 1.0,
            friction: 0.85, // Lower friction for snappier stop on mobile
            pointSize: 0.8
        };

        const CSV_FILE = 'colornames.csv';
        const isMobile = /Android|iPhone|iPad|iPod/i.test(navigator.userAgent);

        // --- THREE.JS SETUP ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x050505);
        scene.fog = new THREE.FogExp2(0x050505, 0.0015);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 2000);
        
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); 
        document.body.appendChild(renderer.domElement);

        // --- CONTROLS LOGIC ---
        let controls;
        if (!isMobile) {
            controls = new PointerLockControls(camera, document.body);
            
            document.addEventListener('click', (e) => {
                if(e.target.closest('#settingsIcon') || e.target.closest('#settingsPanel') || e.target.closest('a')) return;
                controls.lock();
            });

            controls.addEventListener('lock', () => {
                document.getElementById('instructions').style.display = 'none';
                document.getElementById('settingsPanel').style.display = 'none';
                document.getElementById('hud').style.display = 'block';
            });
            controls.addEventListener('unlock', () => {
                document.getElementById('instructions').style.display = 'block';
                document.getElementById('hud').style.display = 'none';
            });
        } else {
            // Mobile Setup
            document.getElementById('startMsg').innerText = "Tap to Start";
            
            document.addEventListener('click', (e) => {
                if(e.target.closest('#settingsIcon') || e.target.closest('#settingsPanel') || e.target.closest('a')) return;
                
                // Fullscreen trigger
                if (document.documentElement.requestFullscreen) {
                    document.documentElement.requestFullscreen().catch(() => {});
                }

                document.getElementById('instructions').style.display = 'none';
                document.getElementById('settingsPanel').style.display = 'none';
                document.getElementById('hud').style.display = 'block';
                document.getElementById('mobileHint').style.display = 'block';
            });
        }

        // --- INPUT HANDLING ---
        const velocity = new THREE.Vector3();
        const move = { fwd: false, bwd: false, left: false, right: false, up: false, down: false };
        
        // Mobile Variables
        const touchInput = { x: 0, z: 0 }; 
        const lookSpeed = 0.004;

        // PC Keyboard
        document.addEventListener('keydown', (e) => {
            switch(e.code) {
                case 'KeyW': move.fwd = true; break;
                case 'KeyS': move.bwd = true; break;
                case 'KeyA': move.left = true; break;
                case 'KeyD': move.right = true; break;
                case 'Space': move.up = true; break;
                case 'ShiftLeft': move.down = true; break;
            }
        });
        document.addEventListener('keyup', (e) => {
            switch(e.code) {
                case 'KeyW': move.fwd = false; break;
                case 'KeyS': move.bwd = false; break;
                case 'KeyA': move.left = false; break;
                case 'KeyD': move.right = false; break;
                case 'Space': move.up = false; break;
                case 'ShiftLeft': move.down = false; break;
            }
        });

        // --- REVISED MOBILE TOUCH LOGIC (SMOOTHER) ---
        if (isMobile) {
            const halfWidth = window.innerWidth / 2;
            let moveTouchId = -1;
            let lookTouchId = -1;
            
            // We store the LAST position to calculate delta for looking
            let lastLookX = 0;
            let lastLookY = 0;
            let moveOriginX = 0;
            let moveOriginY = 0;

            document.addEventListener('touchstart', (e) => {
                if(e.target.closest('#settingsPanel') || e.target.closest('#settingsIcon')) return;

                for (let i = 0; i < e.changedTouches.length; i++) {
                    const t = e.changedTouches[i];
                    if (t.pageX < halfWidth && moveTouchId === -1) {
                        // Left Thumb: Movement Stick anchor
                        moveTouchId = t.identifier;
                        moveOriginX = t.pageX;
                        moveOriginY = t.pageY;
                        touchInput.x = 0;
                        touchInput.z = 0;
                    } else if (t.pageX > halfWidth && lookTouchId === -1) {
                        // Right Thumb: Look anchor
                        lookTouchId = t.identifier;
                        lastLookX = t.pageX;
                        lastLookY = t.pageY;
                    }
                }
            }, {passive: false});

            document.addEventListener('touchmove', (e) => {
                e.preventDefault(); // No scrolling
                for (let i = 0; i < e.changedTouches.length; i++) {
                    const t = e.changedTouches[i];
                    
                    // MOVEMENT (Joystick)
                    if (t.identifier === moveTouchId) {
                        const dx = t.pageX - moveOriginX;
                        const dy = t.pageY - moveOriginY;
                        // Normalize to -1...1 range, capped at 50px drag
                        touchInput.x = Math.max(-1, Math.min(1, dx / 40));
                        touchInput.z = Math.max(-1, Math.min(1, dy / 40));
                    } 
                    
                    // LOOK (1:1 Direct control, no inertia)
                    else if (t.identifier === lookTouchId) {
                        const deltaX = t.pageX - lastLookX;
                        const deltaY = t.pageY - lastLookY;
                        
                        // Apply rotation immediately
                        camera.rotation.y -= deltaX * lookSpeed * settings.speed;
                        camera.rotation.x -= deltaY * lookSpeed * settings.speed;
                        
                        // Clamp vertical look (prevent flipping over)
                        camera.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, camera.rotation.x));
                        
                        // Reset order for proper rotation
                        camera.rotation.order = "YXZ"; 

                        lastLookX = t.pageX;
                        lastLookY = t.pageY;
                    }
                }
            }, {passive: false});

            document.addEventListener('touchend', (e) => {
                for (let i = 0; i < e.changedTouches.length; i++) {
                    const t = e.changedTouches[i];
                    if (t.identifier === moveTouchId) {
                        moveTouchId = -1;
                        touchInput.x = 0;
                        touchInput.z = 0;
                    } else if (t.identifier === lookTouchId) {
                        lookTouchId = -1;
                    }
                }
            });
        }

        // --- SETTINGS LOGIC ---
        document.getElementById('settingsIcon').addEventListener('click', () => {
            const panel = document.getElementById('settingsPanel');
            panel.style.display = panel.style.display === 'block' ? 'none' : 'block';
        });

        document.getElementById('sizeSlider').addEventListener('input', (e) => {
            const val = parseFloat(e.target.value);
            if(pointsMesh) pointsMesh.material.size = val;
            document.getElementById('sizeVal').innerText = val.toFixed(2);
        });

        document.getElementById('speedSlider').addEventListener('input', (e) => {
            const val = parseFloat(e.target.value);
            settings.speed = val;
            document.getElementById('speedVal').innerText = val.toFixed(2);
        });

        document.getElementById('shapeSelect').addEventListener('change', (e) => {
            if(!pointsMesh) return;
            if(e.target.value === 'circle') {
                pointsMesh.material.map = createCircleTexture();
                pointsMesh.material.alphaTest = 0.5;
            } else {
                pointsMesh.material.map = null;
                pointsMesh.material.alphaTest = 0;
            }
            pointsMesh.material.needsUpdate = true;
        });

        document.getElementById('goBtn').addEventListener('click', () => {
            const val = document.getElementById('searchInput').value.trim().toLowerCase();
            if(!val) return;
            const found = colorData.find(c => c.name.toLowerCase() === val || c.hex.toLowerCase() === val);
            if(found) {
                camera.position.set(found.x, found.y, found.z + 20);
                camera.lookAt(found.x, found.y, found.z);
                document.getElementById('settingsPanel').style.display = 'none';
                if(!isMobile) controls.lock();
            } else {
                alert("Color not found.");
            }
        });

        function createCircleTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 32; canvas.height = 32;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.arc(16, 16, 14, 0, Math.PI*2);
            ctx.fill();
            return new THREE.CanvasTexture(canvas);
        }

        // --- PHYSICS ---
        const clock = new THREE.Clock();

        function updatePhysics(delta) {
            // Apply Friction
            velocity.multiplyScalar(settings.friction);

            const camLook = new THREE.Vector3();
            camera.getWorldDirection(camLook);
            
            const camRight = new THREE.Vector3();
            camRight.crossVectors(camLook, camera.up).normalize();

            // Calculate Inputs
            const keyFwd = Number(move.fwd) - Number(move.bwd);
            const keySide = Number(move.right) - Number(move.left);
            const mobFwd = -touchInput.z; 
            const mobSide = touchInput.x;

            const totalFwd = keyFwd + mobFwd;
            const totalSide = keySide + mobSide;

            const accel = settings.speed * 15.0 * delta;

            // Apply forces relative to camera look
            if (Math.abs(totalFwd) > 0) velocity.addScaledVector(camLook, totalFwd * accel);
            if (Math.abs(totalSide) > 0) velocity.addScaledVector(camRight, totalSide * accel);

            if (move.up) velocity.y += accel;
            if (move.down) velocity.y -= accel;

            camera.position.add(velocity);
        }

        // --- LOAD DATA ---
        const toLab = converter('lab');
        const colorData = []; 
        let pointsMesh = null;

        async function initParticles() {
            try {
                const response = await fetch(CSV_FILE);
                const text = await response.text();
                const lines = text.split('\n');
                const positions = [];
                const colors = [];

                for (let i = 1; i < lines.length; i++) {
                    const line = lines[i].trim();
                    if (!line) continue;
                    const parts = line.split(',');
                    if (parts.length < 2) continue;

                    const name = parts[0].trim();
                    const hex = parts[1].trim();
                    const parsed = parse(hex);
                    
                    if (parsed) {
                        const lab = toLab(parsed);
                        const x = lab.a * 3; 
                        const y = (lab.l - 50) * 4; 
                        const z = lab.b * 3; 

                        positions.push(x, y, z);
                        const color = new THREE.Color(hex);
                        colors.push(color.r, color.g, color.b);
                        colorData.push({ name, hex, x, y, z });
                    }
                }

                const geometry = new THREE.BufferGeometry();
                geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
                geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
                const material = new THREE.PointsMaterial({ size: settings.pointSize, vertexColors: true, sizeAttenuation: true });
                pointsMesh = new THREE.Points(geometry, material);
                scene.add(pointsMesh);
                
                camera.position.set(0, 0, 250);
                document.getElementById('loading').style.display = 'none';
            } catch (err) {
                document.getElementById('loading').innerText = "Error loading CSV (Use Local Server!)";
            }
        }

        initParticles();

        // --- LABELS ---
        function createTextSprite(message, color) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 512; canvas.height = 256; // Higher res
            ctx.font = "Bold 80px Arial";
            ctx.fillStyle = color;
            ctx.textAlign = "center";
            ctx.fillText(message, 256, 150);
            const sprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: new THREE.CanvasTexture(canvas) }));
            sprite.scale.set(80, 40, 1);
            return sprite;
        }

        function addLabels() {
            const g = new THREE.Group();
            const gridHelper = new THREE.GridHelper(600, 20, 0x222222, 0x111111);
            gridHelper.position.y = -200;
            g.add(gridHelper);

            const lTop = createTextSprite("+Lightness", "#ffffff"); lTop.position.set(0, 220, 0); g.add(lTop);
            const lBot = createTextSprite("-Lightness", "#555555"); lBot.position.set(0, -220, 0); g.add(lBot);
            const aPos = createTextSprite("+A (Red)", "#ff4444"); aPos.position.set(200, 0, 0); g.add(aPos);
            const aNeg = createTextSprite("-A (Green)", "#44ff44"); aNeg.position.set(-200, 0, 0); g.add(aNeg);
            const bPos = createTextSprite("+B (Yellow)", "#ffff44"); bPos.position.set(0, 0, 200); g.add(bPos);
            const bNeg = createTextSprite("-B (Blue)", "#4444ff"); bNeg.position.set(0, 0, -200); g.add(bNeg);

            scene.add(g);
        }
        addLabels();

        // --- HOVER ---
        const lookVector = new THREE.Vector3();
        function checkHover() {
            if (colorData.length === 0) return;
            // Always check on mobile, or if mouse locked on PC
            if (!isMobile && !controls.isLocked) return; 

            const camPos = camera.position;
            camera.getWorldDirection(lookVector);

            let bestDist = Infinity;
            let bestIdx = -1;

            for (let i = 0; i < colorData.length; i += 1) { 
                const p = colorData[i];
                const dx = p.x - camPos.x;
                const dy = p.y - camPos.y;
                const dz = p.z - camPos.z;
                const distSq = dx*dx + dy*dy + dz*dz;

                if (distSq < 2500) { // Range 50 units
                    const dist = Math.sqrt(distSq);
                    const dot = (dx/dist * lookVector.x) + (dy/dist * lookVector.y) + (dz/dist * lookVector.z);
                    // Angle tolerance
                    if (dot > 0.999) {
                        if (dist < bestDist) {
                            bestDist = dist;
                            bestIdx = i;
                        }
                    }
                }
            }

            if (bestIdx !== -1) {
                const c = colorData[bestIdx];
                document.getElementById('colorName').innerText = c.name;
                document.getElementById('colorHex').innerText = c.hex;
                document.getElementById('colorName').style.color = c.hex;
                document.getElementById('crosshair').style.width = "16px";
                document.getElementById('crosshair').style.height = "16px";
            } else {
                document.getElementById('colorName').innerText = "---";
                document.getElementById('colorHex').innerText = "---";
                document.getElementById('colorName').style.color = "white";
                document.getElementById('crosshair').style.width = "8px";
                document.getElementById('crosshair').style.height = "8px";
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            const delta = Math.min(clock.getDelta(), 0.1);
            updatePhysics(delta);
            checkHover();
            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>